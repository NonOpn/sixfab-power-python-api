<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>power_api.power_api API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>power_api.power_api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python3

import time
import datetime
from power_api.command import Command
from power_api.definitions import Definition
from power_api.event import Event
import os

command = Command()

#############################################################
### Communication Protocol ##################################
#############################################################
buffer_send = list()
buffer_receive = list()
buffer_recieve_index = 0

RESPONSE_DELAY = 10

START_BYTE_RECIEVED = 0xDC  # Start Byte Recieved
START_BYTE_SENT = 0xCD  # Start Byte Sent
PROTOCOL_HEADER_SIZE = 5
PROTOCOL_FRAME_SIZE = 7
COMMAND_SIZE_FOR_FLOAT = 11
COMMAND_SIZE_FOR_DOUBLE = 13
COMMAND_SIZE_FOR_INT16 = 9
COMMAND_SIZE_FOR_INT32 = 11
COMMAND_SIZE_FOR_UINT8 = 8
COMMAND_SIZE_FOR_INT64 = 15

COMMAND_TYPE_REQUEST = 0x01
COMMAND_TYPE_RESPONSE = 0x02

DEVICE_ADDRESS = 0x41  # 7 bit address (will be left shifted to add the read write bit)


###########################################
### Private Methods #######################
###########################################


def debug_print(message):
    &#34;&#34;&#34;Function for printing debug message.&#34;&#34;&#34;
    print(message)


def millis():
    &#34;&#34;&#34;Function for getting time as miliseconds.&#34;&#34;&#34;
    return int(time.time())


def delay_ms(ms):
    &#34;&#34;&#34;Function for delay as miliseconds.&#34;&#34;&#34;
    time.sleep(float(ms / 1000.0))


#############################################################
### SIXFAB POWER CLASS ######################################
#############################################################
class SixfabPower:
    &#34;&#34;&#34; 
    Sixfab Power Class.
    
    &#34;&#34;&#34;

    board = &#34;Sixfab Raspberry Pi UPS HAT&#34;

    # Initializer function
    def __init__(self):
        # debug_print(self.board + &#34; Class initialized!&#34;)
        pass

    def __del__(self):
        # print(&#34;Class Destructed&#34;)
        pass

    #############################################################
    ### API Call Methods ########################################
    #############################################################

    def get_input_temp(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;Function for getting input temperature
        
        Parameters
        -----------             
        timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        temperature : float 
        PCB temperature of Sixfab Power Management and UPS HAT [Celcius]  
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_TEMP)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        temp = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return temp / 100

    def get_input_voltage(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting input voltage
        
        Parameters
        -----------     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        voltage : float 
            input voltage [Volt] 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_VOLTAGE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        voltage = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return voltage / 1000

    def get_input_current(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting input current
        
        Parameters
        -----------                     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        current : float 
            input current [Ampere] 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_CURRENT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        current = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return current / 1000

    def get_input_power(self, timeout=50):
        &#34;&#34;&#34;
        Function for getting input power
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        power : float
            input power [Watt] 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_POWER)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        power = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return power / 1000

    def get_system_temp(self):
        &#34;&#34;&#34;
        Function for getting raspberry pi core temperature
        
        Parameters
        -----------     
        None

        Returns
        ------- 
        temperature : float
            raspberry pi core temperature [Celcius] 
        &#34;&#34;&#34;
        temp = os.popen(&#34;vcgencmd measure_temp&#34;).readline()
        temp = temp.replace(&#34;temp=&#34;, &#34;&#34;)
        return float(temp[:-3])

    def send_system_temp(self, timeout=10):
        &#34;&#34;&#34;
        Function for sending raspberry pi core temperature to mcu
        
        Parameters
        -----------     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SUCCESS, &#34;2&#34; for FAIL
        &#34;&#34;&#34;

        temp = self.get_system_temp()
        tempInt = int(temp * 100)

        command.create_set_command(command.PROTOCOL_COMMAND_GET_SYSTEM_TEMP, tempInt, 4)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_system_voltage(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting system voltage
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        voltage : float
            voltage source that supplies raspberry pi and other peripherals [Volt]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_SYSTEM_VOLTAGE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        voltage = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return voltage / 1000

    def get_system_current(self, timeout=50):
        &#34;&#34;&#34;
        Function for getting system current
        
        Parameters
        -----------     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        current : float
            current that supplies raspberry pi and other peripherals [Ampere]
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_SYSTEM_CURRENT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        current = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return current / 1000

    def get_system_power(self, timeout=50):
        &#34;&#34;&#34;
        Function for getting system power
        
        Parameters
        -----------     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        power : float
            power that supplies raspberry pi and other peripherals [Ampere]
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_SYSTEM_POWER)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        power = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return power / 1000

    def get_battery_temp(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery temperature
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        temperature : float
            battery temperature [Celcius]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_TEMP)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        temp = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return temp / 100

    def get_battery_voltage(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery voltage
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        voltage : float 
            battery voltage [Volt]
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_VOLTAGE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        voltage = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return voltage / 1000

    def get_battery_current(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery current
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        current : float
            battery current [Ampere]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_CURRENT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        current = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;, signed=True
        )
        return current / 1000

    def get_battery_power(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery power
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        power : float
            battery power [Watt]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_POWER)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        power = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;, signed=True
        )
        return power / 1000

    def get_battery_level(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery level
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        level : int
            battery charge of state as percentage [%]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_LEVEL)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        level = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return level

    def get_fan_health(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting fan health
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        health : int
            &#34;1&#34; for HEALTHY, &#34;2&#34; for BROKEN
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FAN_HEALTH)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        health = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return health

    def get_battery_health(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery health
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        health : int
            battery health as percentage [%] 
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_HEALTH)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        health = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return health

    def get_fan_speed(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting fan speed
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        speed : int
            fan speed [RPM] 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FAN_SPEED)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        rpm = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return rpm


    def get_watchdog_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting watchdog status
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for WATCHDOG ENABLED, &#34;2&#34; for WATCHDOG DISABLED 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_WATCHDOG_STATUS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def set_watchdog_status(self, status, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting watchdog status
        
        Parameters
        -----------
        status : &#34;1&#34; for WATCHDOG ENABLED, &#34;2&#34; for WATCHDOG DISABLED
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED 
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_WATCHDOG_STATUS, status, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def set_rgb_animation(self, anim_type, color, speed, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting RGB animation
        
        Parameters
        -----------
        anim_type : [DISABLED, HEARTBEAT, TEMP_MAP]
        color : [GREEN, BLUE, RED, YELLOW, CYAN, MAGENTA, WHITE]
        speed : [SLOW, NORMAL, FAST] 
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED 
        &#34;&#34;&#34;

        value = bytearray()
        value.append(int(anim_type))
        value.append(int(color))
        value.append(int(speed))

        command.create_set_command(command.PROTOCOL_COMMAND_SET_RGB_ANIMATION, value, 3)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_rgb_animation(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting RGB animation
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        animation : byteArray(3)
            [anim_type, color, speed]

        Notes
        -----
        anim_type : Definition Object Property
            --&gt; Definition.RGB_DISABLED
            --&gt; Definition.RGB_HEARTBEAT
            --&gt; Definition.RGB_TEMP_MAP

        color : Definition Object Property
            --&gt; Definition.RED
            --&gt; Definition.GREEN
            --&gt; Definition.BLUE
            --&gt; Definition.YELLOW
            --&gt; Definition.CYAN
            --&gt; Definition.MAGENTA
            --&gt; Definition.WHITE
            --&gt; Definition.BLACK
        
        speed : Definition Object Property
            --&gt; Definition.SLOW
            --&gt; Definition.NORMAL
            --&gt; Definition.FAST
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_RGB_ANIMATION)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(10)

        animation = bytearray()
        for i in range(3):
            animation.append(raw[PROTOCOL_HEADER_SIZE + i])

        return animation

    def set_fan_automation(
        self, slow_threshold, fast_threshold=100, timeout=RESPONSE_DELAY
    ):
        &#34;&#34;&#34;
        Function for setting fan automation
        
        Parameters
        -----------
        slow_threshold : int
            temperature threshold to decide fan working status
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED 
        &#34;&#34;&#34;

        value = bytearray()
        value.append(int(slow_threshold))
        value.append(int(fast_threshold))

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_FAN_AUTOMATION, value, 2
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_fan_automation(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting fan automation
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        automation : byteArray(2) 
            [slow_threshold, fast_threshold] [Celcius]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FAN_AUTOMATION)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(9)

        fanAutomation = bytearray()
        for i in range(2):
            fanAutomation.append(raw[PROTOCOL_HEADER_SIZE + i])

        return fanAutomation

    def set_battery_max_charge_level(self, level, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting battery max charge level
        
        Parameters
        -----------
        level : int
            battery is charged up to this level in percentage [%]
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_BATTERY_MAX_CHARGE_LEVEL, level, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        level = raw[PROTOCOL_HEADER_SIZE]
        return level

    def get_battery_max_charge_level(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery max charge level
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        level : int
            battery max charge level in percentage [%]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_MAX_CHARGE_LEVEL)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        level = raw[PROTOCOL_HEADER_SIZE]
        return level

    def set_safe_shutdown_battery_level(self, level, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting safe shutdown battery level
        
        Parameters
        -----------
        level : int
            raspberry pi is turned off if battery falls to this level
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_SAFE_SHUTDOWN_BATTERY_LEVEL, level, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        level = raw[PROTOCOL_HEADER_SIZE]
        return level

    def get_safe_shutdown_battery_level(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting safe shutdown battery level
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        level : int
            safe shutdown level in percentage [%]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_SAFE_SHUTDOWN_BATTERY_LEVEL)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        level = raw[PROTOCOL_HEADER_SIZE]
        return level

    def set_safe_shutdown_status(self, status, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting safe shutdown status
        
        Parameters
        -----------
        status : int
            &#34;1&#34; for ENABLED, &#34;2&#34; for DISABLED
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_SAFE_SHUTDOWN_STATUS, status, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def get_safe_shutdown_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting safe shutdown status
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for ENABLEDi &#34;2&#34; for DISABLED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_SAFE_SHUTDOWN_STATUS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def get_working_mode(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting working mode
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        working_mode : int
            &#34;1&#34; for CHARGING, &#34;2&#34; for FULLY_CHARGED, &#34;3&#34; for BATTERY POWERED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_WORKING_MODE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        mode = raw[PROTOCOL_HEADER_SIZE]
        return mode

    def get_button1_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting button 1
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for SHORT_PRESS, &#34;2&#34; for LONG_PRESS, &#34;3&#34; for RELEASED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BUTTON1_STATUS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def get_button2_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting button 2
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for SHORT_PRESS, &#34;2&#34; for LONG_PRESS, &#34;3&#34; for RELEASED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BUTTON2_STATUS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def set_rtc_time(self, timestamp, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting time of RTC in MCU
        
        Parameters
        -----------
        time : int
            epoch time
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_set_command(command.PROTOCOL_COMMAND_SET_RTC_TIME, timestamp, 4)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_rtc_time(self, format=Definition.TIME_FORMAT_EPOCH, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting time of RTC in MCU
        
        Parameters
        -----------
        format : Definition Object Property
            --&gt; Definition.TIME_FORMAT_EPOCH
            --&gt; Definition.TIME_FORMAT_DATE_AND_TIME
            --&gt; Definition.TIME_FORMAT_DATE
            --&gt; Definition.TIME_FORMAT_TIME
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        timestamp : int/str
            time in chosen format
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_RTC_TIME)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        timestamp = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )

        if format == Definition.TIME_FORMAT_EPOCH:
            return timestamp
        elif format == Definition.TIME_FORMAT_DATE_AND_TIME:
            date_and_time = datetime.datetime.utcfromtimestamp(timestamp).strftime(
                &#34;%Y-%m-%d %H:%M:%S&#34;
            )
            return date_and_time
        elif format == Definition.TIME_FORMAT_DATE:
            date = datetime.datetime.utcfromtimestamp(timestamp).strftime(&#34;%Y-%m-%d&#34;)
            return date
        elif format == Definition.TIME_FORMAT_TIME:
            time = datetime.datetime.utcfromtimestamp(timestamp).strftime(&#34;%H:%M:%S&#34;)
            return time

    def hard_power_off(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for raspberry pi hard powering off
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_HARD_POWER_OFF)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def soft_power_off(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for checking any soft power off request is exist. If any
        request exist, raspberry pi turns off by using &#34;sudo shutdown&#34; terminal
        command in 5 seconds.
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for EXIST, &#34;2&#34; for NOT_EXIST
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_SOFT_POWER_OFF)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)
        result2 = 0
        result = raw[PROTOCOL_HEADER_SIZE]

        if result == Definition.SET_OK:
            command.create_set_command(command.PROTOCOL_COMMAND_SOFT_POWER_OFF, 1, 1)
            command.send_command()
            delay_ms(timeout)
            raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)
            result2 = raw[PROTOCOL_HEADER_SIZE]

            if result2 == Definition.SET_OK:
                print(&#34;Raspberry Pi will shutdown in 5 seconds!&#34;)
                os.system(&#34;sleep 5 &amp;&amp; sudo shutdown -h now&#34;)
                return result2

        return Definition.SET_FAILED

    def hard_reboot(self, timeout=100):
        &#34;&#34;&#34;
        Function for hard rebooting
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_HARD_REBOOT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def soft_reboot(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for checking any soft reboot request is exist. If any
        request exist, raspberry pi reboots by using &#34;sudo reboot&#34; terminal
        command in 5 seconds.
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for EXIST, &#34;2&#34; for NOT_EXIST
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_SOFT_REBOOT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result2 = 0
        result = raw[PROTOCOL_HEADER_SIZE]

        if result == Definition.SET_OK:
            command.create_set_command(command.PROTOCOL_COMMAND_SOFT_REBOOT, 1, 1)
            command.send_command()
            delay_ms(timeout)
            raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)
            result2 = raw[PROTOCOL_HEADER_SIZE]

            if result2 == Definition.SET_OK:
                print(&#34;Raspberry Pi will shutdown in 5 seconds!&#34;)
                os.system(&#34;sleep 5 &amp;&amp; sudo reboot&#34;)
                return result2

        return Definition.SET_FAILED

    def ask_watchdog_alarm(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for asking watchdog alarm is exist
            
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for EXIST, &#34;2&#34; for NOT_EXIST
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMAMND_WATCHDOG_ALARM)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

        alarm_status = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT16 - 2], &#34;big&#34;
        )
        return alarm_status

    def get_battery_design_capacity(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery design capacity
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        capacity : int
            battery design capacity in [mAh]
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_DESIGN_CAPACITY)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

        capacity = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT16 - 2], &#34;big&#34;
        )
        return capacity

    def set_battery_design_capacity(self, capacity, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting battery design capacity
        
        Parameters
        -----------
        capacity : int
            battery design capacity in [mAh]
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED 
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_BATTERY_DESIGN_CAPACITY, capacity, 2
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def create_scheduled_event(
        self,
        event_id,
        schedule_type,
        repeat,
        time_or_interval,
        interval_type,
        repeat_period,
        action,
        timeout=200,
    ):
        &#34;&#34;&#34;
        Function for creating scheduling event
        
        Parameters
        -----------
        event_id : int 
            id to describe events indivudially

        schedule_type : Definition Object Property
            --&gt; Definition.NO_EVENT
            --&gt; Definition.EVENT_TIME
            --&gt; Definition.EVENT_INTERVAL

        repeat : Definition Object Property
            --&gt; Definition.EVENT_ONE_SHOT
            --&gt; Definition.EVENT_REPEATED

        time_or_interval : int
            daily_epoch_time in seconds or interval (Checkout *Notes for daily_exact_time)

        interval_type : Definition Object Property 
            --&gt; Definition.INTERVAL_TYPE_SEC
            --&gt; Definition.INTERVAL_TYPE_MIN
            --&gt; Definition.INTERVAL_TYPE_HOUR 

        repeat_period : int
            day_factor (Checkout *Notes)

        action : int
            --&gt; &#34;1&#34; for START
            --&gt; &#34;2&#34; for HARD SHUTDOWN
            --&gt; &#34;3&#34; for SOFT SHUTDOWN
            --&gt; &#34;4&#34; for HARD REBOOT
            --&gt; &#34;5&#34; for SOFT REBOOT

         timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Notes
        -----
        1) Calculation of daily_exact_time :
        daily exact_time formula: epoch_time_local % (24*60*60)
        
        daily exact time example: 
        --&gt; Friday, March 27, 2020 11:19:00 PM GMT+03:00
        --&gt; epoch_local = 1585340340 (In this case local : GMT+3)
        --&gt; daily exact_time = 1585340340 % 86400 = 73140
        
        2) Calculation of day_factor                                                             
        [monday] --&gt; Bit 0
        [tuesday] --&gt; Bit 1
        [wednesday] --&gt; Bit 2
        [thursday] --&gt; Bit 3
        [friday] --&gt; Bit 4
        [saturday] --&gt; Bit 5
        [sunday] --&gt; Bit 6
        [RESERVED] --&gt; Bit 7 (Default 0)
                                                     
        Example Calculation for every day : 
        day_factor = 0b01111111 = 127
        
        Example Calculation for (sunday + monday + tuesday) :
        day_factor = 0b01000011 = 67

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED 
        &#34;&#34;&#34;

        value = bytearray()
        value.append(event_id)
        value.append(schedule_type)
        value.append(repeat)
        value.append((time_or_interval &gt;&gt; 24) &amp; 0xFF)
        value.append((time_or_interval &gt;&gt; 16) &amp; 0xFF)
        value.append((time_or_interval &gt;&gt; 8) &amp; 0xFF)
        value.append(time_or_interval &amp; 0xFF)
        value.append(interval_type)
        value.append(repeat_period)
        value.append(action)

        command.create_set_command(
            command.PROTOCOL_COMMAND_CREATE_SCHEDULED_EVENT, value, 10
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def create_scheduled_event_with_event(self, event, timeout=200):
        &#34;&#34;&#34;
        Function for creating scheduling event
        
        Parameters
        -----------
        event : Event Class Object
            instance of Event class
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED 
        &#34;&#34;&#34;

        value = bytearray()
        value.append(event.id)
        value.append(event.schedule_type)
        value.append(event.repeat)
        value.append((event.time_interval &gt;&gt; 24) &amp; 0xFF)
        value.append((event.time_interval &gt;&gt; 16) &amp; 0xFF)
        value.append((event.time_interval &gt;&gt; 8) &amp; 0xFF)
        value.append(event.time_interval &amp; 0xFF)
        value.append(event.interval_type)
        value.append(event.day)
        value.append(event.action)

        command.create_set_command(
            command.PROTOCOL_COMMAND_CREATE_SCHEDULED_EVENT, value, 10
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_scheduled_event_ids(self, timeout=50):
        &#34;&#34;&#34;
        Function for getting scheduled event ids
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        ids : byteArray(10)
            active ids of scheduled events 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_SCHEDULED_EVENT_IDS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

        ids = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT16 - 2], &#34;big&#34;
        )
        ids_bytes = bytearray()

        for i in range(10):
            if ids &amp; (1 &lt;&lt; i):
                ids_bytes.append(i + 1)
        return ids_bytes

    def remove_scheduled_event(self, event_id, timeout=200):
        &#34;&#34;&#34;
        Function for removing scheduling event with event id
        
        Parameters
        -----------
        event_id : int
            event id that is required to remove
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_REMOVE_SCHEDULED_EVENT, event_id, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def remove_all_scheduled_events(self, timeout=200):
        &#34;&#34;&#34;
        Function for removing all scheduling events
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_REMOVE_ALL_SCHEDULED_EVENTS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_firmware_ver(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting firmware version on mcu
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        version : char[8] 
            ver [Ex. v1.00.00]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FIRMWARE_VER)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(15)
        ver = bytearray(8)

        for i in range(8):
            ver[i] = raw[PROTOCOL_HEADER_SIZE + i]

        ver_str = ver.decode(&#34;utf-8&#34;)
        return ver_str

    def update_firmware(self, firmware_file, update_method=0, timeout=25):
        &#34;&#34;&#34;
        Function for updating mcu firmware. Do not make any other api call while update call is running.
        
        Parameters
        -----------
        firmware_file : str
            .bin file path
        update_method : int (optional)
            &#34;0&#34; for boot_mode_update, &#34;1&#34; for firmware_mode_update (default is 0)
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Yields
        ------
        process : int
            Process [%] on every step

        Returns
        ------- 
        result : int
            &#34;1&#34; for SUCCESS, &#34;2&#34; for FAIL
        &#34;&#34;&#34;

        packet_id = 0
        requesting_packet_id = 1
        packet_size = 20

        # Calculate packet count
        f = open(firmware_file, &#34;rb&#34;)
        all_data = f.read()
        leap_packet_size = len(all_data) % packet_size
        packet_count = int(len(all_data) / packet_size) + 1
        
        if leap_packet_size == 0:
             packet_count = int(len(all_data) / packet_size)

        f.close()

        # open file
        f = open(firmware_file, &#34;rb&#34;)
        data = bytes()

        # Clear program storage for saving new program data
        result = self.clear_program_storage()
        # print(&#34;Program Storage Clear Result: &#34; + str(result))
        if result != 1:
            return Definition.SET_FAILED

        last_process = 0  # for process bar

        # choose the update_method
        if update_method == 0:
            self.reset_for_boot_update()
            delay_ms(800)

        # If any data exist
        while data or (packet_id == 0):
            if packet_id != requesting_packet_id:
                data = f.read(packet_size)
                packet_id += 1

            # calculate the process
            process = int((packet_id * 100) / packet_count)
            yielded_value = None

            if process != last_process:
                if yielded_value != process:
                    yielded_value = process
                    yield process

                last_process = process

            # send data to MCU
            if data:
                if packet_id == packet_count:
                    command.create_firmware_update_command(
                        packet_count,
                        requesting_packet_id,
                        data,
                        packet_len=leap_packet_size,
                    )
                    command.send_command()
                    delay_ms(timeout)
                    raw = command.receive_command(COMMAND_SIZE_FOR_INT16)
                else:
                    command.create_firmware_update_command(
                        packet_count, requesting_packet_id, data
                    )
                    command.send_command()
                    delay_ms(timeout)
                    raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

                try:
                    requesting_packet_id = (raw[5] &lt;&lt; 8) | (raw[6] &amp; 0xFF)
                    # print(&#34;Last Packet Read --&gt; &#34; + str(packet_id))
                    # print(&#34;Requesting --&gt; &#34; + str(requesting_packet_id))

                    # if final packet comes
                    if requesting_packet_id == 0xFFFF:
                        print(&#34;Firmware packages are being writen to flash...&#34;)
                        print(&#34;Please wait until the application starts!&#34;)
                        self.reset_mcu()
                        return
                except:
                    raise ValueError(&#34;None Object Exception&#34;)

        # if firmware update doesn&#39;t ended succesfully
        raise RuntimeError(&#34;Unidentified Runtime Exception&#34;)

    def clear_program_storage(self, timeout=500):
        &#34;&#34;&#34;
        Function for clearing firmware storage
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SUCCESS, &#34;2&#34; for FAIL
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_CLEAR_PROGRAM_STORAGE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def reset_mcu(self):
        &#34;&#34;&#34;
        Function for resetting MCU
        
        Parameters
        -----------
        None

        Returns
        ------- 
        None
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_RESET_MCU)
        command.send_command()

    def reset_for_boot_update(self):
        &#34;&#34;&#34;
        Function for resetting MCU and go to boot mode
        
        Parameters
        -----------
        None

        Returns
        ------- 
        None
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_RESET_MCU_FOR_BOOT_UPDATE)
        command.send_command()

    
    def get_lpm_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting low power mode status
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for LPM ENABLED, &#34;2&#34; for LPM DISABLED 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_LOW_POWER_MODE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status


    def get_edm_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting easy deployment mode status
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for EDM ENABLED, &#34;2&#34; for EDM DISABLED 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_EASY_DEPLOYMENT_MODE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status


    def set_lpm_status(self, status, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting low power mode status
        
        Parameters
        -----------
        status : int
            &#34;1&#34; for ENABLED, &#34;2&#34; for DISABLED
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_LOW_POWER_MODE, status, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status


    def set_edm_status(self, status, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting easy deployment mode status
        
        Parameters
        -----------
        status : int
            &#34;1&#34; for ENABLED, &#34;2&#34; for DISABLED
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_EASY_DEPLOYMENT_MODE, status, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status
    
    
    def set_fan_mode(self, mode, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting fan mode
        
        Parameters
        -----------
        status : int
            &#34;1&#34; for FAN ON MODE, &#34;2&#34; for FAN OFF MODE, &#34;3&#34; for FAN AUTO MODE 
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_FAN_MODE, mode, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status


    def get_fan_mode(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting fan mode
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for FAN ON MODE, &#34;2&#34; for FAN OFF MODE, &#34;3&#34; for FAN AUTO MODE 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FAN_MODE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="power_api.power_api.debug_print"><code class="name flex">
<span>def <span class="ident">debug_print</span></span>(<span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for printing debug message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_print(message):
    &#34;&#34;&#34;Function for printing debug message.&#34;&#34;&#34;
    print(message)</code></pre>
</details>
</dd>
<dt id="power_api.power_api.delay_ms"><code class="name flex">
<span>def <span class="ident">delay_ms</span></span>(<span>ms)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for delay as miliseconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay_ms(ms):
    &#34;&#34;&#34;Function for delay as miliseconds.&#34;&#34;&#34;
    time.sleep(float(ms / 1000.0))</code></pre>
</details>
</dd>
<dt id="power_api.power_api.millis"><code class="name flex">
<span>def <span class="ident">millis</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting time as miliseconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def millis():
    &#34;&#34;&#34;Function for getting time as miliseconds.&#34;&#34;&#34;
    return int(time.time())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="power_api.power_api.SixfabPower"><code class="flex name class">
<span>class <span class="ident">SixfabPower</span></span>
</code></dt>
<dd>
<div class="desc"><p>Sixfab Power Class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SixfabPower:
    &#34;&#34;&#34; 
    Sixfab Power Class.
    
    &#34;&#34;&#34;

    board = &#34;Sixfab Raspberry Pi UPS HAT&#34;

    # Initializer function
    def __init__(self):
        # debug_print(self.board + &#34; Class initialized!&#34;)
        pass

    def __del__(self):
        # print(&#34;Class Destructed&#34;)
        pass

    #############################################################
    ### API Call Methods ########################################
    #############################################################

    def get_input_temp(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;Function for getting input temperature
        
        Parameters
        -----------             
        timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        temperature : float 
        PCB temperature of Sixfab Power Management and UPS HAT [Celcius]  
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_TEMP)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        temp = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return temp / 100

    def get_input_voltage(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting input voltage
        
        Parameters
        -----------     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        voltage : float 
            input voltage [Volt] 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_VOLTAGE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        voltage = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return voltage / 1000

    def get_input_current(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting input current
        
        Parameters
        -----------                     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        current : float 
            input current [Ampere] 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_CURRENT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        current = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return current / 1000

    def get_input_power(self, timeout=50):
        &#34;&#34;&#34;
        Function for getting input power
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        power : float
            input power [Watt] 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_POWER)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        power = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return power / 1000

    def get_system_temp(self):
        &#34;&#34;&#34;
        Function for getting raspberry pi core temperature
        
        Parameters
        -----------     
        None

        Returns
        ------- 
        temperature : float
            raspberry pi core temperature [Celcius] 
        &#34;&#34;&#34;
        temp = os.popen(&#34;vcgencmd measure_temp&#34;).readline()
        temp = temp.replace(&#34;temp=&#34;, &#34;&#34;)
        return float(temp[:-3])

    def send_system_temp(self, timeout=10):
        &#34;&#34;&#34;
        Function for sending raspberry pi core temperature to mcu
        
        Parameters
        -----------     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SUCCESS, &#34;2&#34; for FAIL
        &#34;&#34;&#34;

        temp = self.get_system_temp()
        tempInt = int(temp * 100)

        command.create_set_command(command.PROTOCOL_COMMAND_GET_SYSTEM_TEMP, tempInt, 4)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_system_voltage(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting system voltage
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        voltage : float
            voltage source that supplies raspberry pi and other peripherals [Volt]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_SYSTEM_VOLTAGE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        voltage = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return voltage / 1000

    def get_system_current(self, timeout=50):
        &#34;&#34;&#34;
        Function for getting system current
        
        Parameters
        -----------     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        current : float
            current that supplies raspberry pi and other peripherals [Ampere]
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_SYSTEM_CURRENT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        current = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return current / 1000

    def get_system_power(self, timeout=50):
        &#34;&#34;&#34;
        Function for getting system power
        
        Parameters
        -----------     
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        power : float
            power that supplies raspberry pi and other peripherals [Ampere]
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_SYSTEM_POWER)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        power = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return power / 1000

    def get_battery_temp(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery temperature
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        temperature : float
            battery temperature [Celcius]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_TEMP)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        temp = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return temp / 100

    def get_battery_voltage(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery voltage
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        voltage : float 
            battery voltage [Volt]
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_VOLTAGE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        voltage = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return voltage / 1000

    def get_battery_current(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery current
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        current : float
            battery current [Ampere]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_CURRENT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        current = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;, signed=True
        )
        return current / 1000

    def get_battery_power(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery power
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        power : float
            battery power [Watt]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_POWER)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        power = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;, signed=True
        )
        return power / 1000

    def get_battery_level(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery level
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        level : int
            battery charge of state as percentage [%]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_LEVEL)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        level = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return level

    def get_fan_health(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting fan health
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        health : int
            &#34;1&#34; for HEALTHY, &#34;2&#34; for BROKEN
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FAN_HEALTH)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        health = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return health

    def get_battery_health(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery health
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        health : int
            battery health as percentage [%] 
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_HEALTH)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        health = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return health

    def get_fan_speed(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting fan speed
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        speed : int
            fan speed [RPM] 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FAN_SPEED)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        rpm = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )
        return rpm


    def get_watchdog_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting watchdog status
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for WATCHDOG ENABLED, &#34;2&#34; for WATCHDOG DISABLED 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_WATCHDOG_STATUS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def set_watchdog_status(self, status, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting watchdog status
        
        Parameters
        -----------
        status : &#34;1&#34; for WATCHDOG ENABLED, &#34;2&#34; for WATCHDOG DISABLED
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED 
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_WATCHDOG_STATUS, status, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def set_rgb_animation(self, anim_type, color, speed, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting RGB animation
        
        Parameters
        -----------
        anim_type : [DISABLED, HEARTBEAT, TEMP_MAP]
        color : [GREEN, BLUE, RED, YELLOW, CYAN, MAGENTA, WHITE]
        speed : [SLOW, NORMAL, FAST] 
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED 
        &#34;&#34;&#34;

        value = bytearray()
        value.append(int(anim_type))
        value.append(int(color))
        value.append(int(speed))

        command.create_set_command(command.PROTOCOL_COMMAND_SET_RGB_ANIMATION, value, 3)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_rgb_animation(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting RGB animation
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        animation : byteArray(3)
            [anim_type, color, speed]

        Notes
        -----
        anim_type : Definition Object Property
            --&gt; Definition.RGB_DISABLED
            --&gt; Definition.RGB_HEARTBEAT
            --&gt; Definition.RGB_TEMP_MAP

        color : Definition Object Property
            --&gt; Definition.RED
            --&gt; Definition.GREEN
            --&gt; Definition.BLUE
            --&gt; Definition.YELLOW
            --&gt; Definition.CYAN
            --&gt; Definition.MAGENTA
            --&gt; Definition.WHITE
            --&gt; Definition.BLACK
        
        speed : Definition Object Property
            --&gt; Definition.SLOW
            --&gt; Definition.NORMAL
            --&gt; Definition.FAST
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_RGB_ANIMATION)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(10)

        animation = bytearray()
        for i in range(3):
            animation.append(raw[PROTOCOL_HEADER_SIZE + i])

        return animation

    def set_fan_automation(
        self, slow_threshold, fast_threshold=100, timeout=RESPONSE_DELAY
    ):
        &#34;&#34;&#34;
        Function for setting fan automation
        
        Parameters
        -----------
        slow_threshold : int
            temperature threshold to decide fan working status
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED 
        &#34;&#34;&#34;

        value = bytearray()
        value.append(int(slow_threshold))
        value.append(int(fast_threshold))

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_FAN_AUTOMATION, value, 2
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_fan_automation(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting fan automation
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        automation : byteArray(2) 
            [slow_threshold, fast_threshold] [Celcius]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FAN_AUTOMATION)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(9)

        fanAutomation = bytearray()
        for i in range(2):
            fanAutomation.append(raw[PROTOCOL_HEADER_SIZE + i])

        return fanAutomation

    def set_battery_max_charge_level(self, level, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting battery max charge level
        
        Parameters
        -----------
        level : int
            battery is charged up to this level in percentage [%]
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_BATTERY_MAX_CHARGE_LEVEL, level, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        level = raw[PROTOCOL_HEADER_SIZE]
        return level

    def get_battery_max_charge_level(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery max charge level
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        level : int
            battery max charge level in percentage [%]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_MAX_CHARGE_LEVEL)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        level = raw[PROTOCOL_HEADER_SIZE]
        return level

    def set_safe_shutdown_battery_level(self, level, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting safe shutdown battery level
        
        Parameters
        -----------
        level : int
            raspberry pi is turned off if battery falls to this level
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_SAFE_SHUTDOWN_BATTERY_LEVEL, level, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        level = raw[PROTOCOL_HEADER_SIZE]
        return level

    def get_safe_shutdown_battery_level(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting safe shutdown battery level
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        level : int
            safe shutdown level in percentage [%]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_SAFE_SHUTDOWN_BATTERY_LEVEL)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        level = raw[PROTOCOL_HEADER_SIZE]
        return level

    def set_safe_shutdown_status(self, status, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting safe shutdown status
        
        Parameters
        -----------
        status : int
            &#34;1&#34; for ENABLED, &#34;2&#34; for DISABLED
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_SAFE_SHUTDOWN_STATUS, status, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def get_safe_shutdown_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting safe shutdown status
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for ENABLEDi &#34;2&#34; for DISABLED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_SAFE_SHUTDOWN_STATUS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def get_working_mode(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting working mode
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        working_mode : int
            &#34;1&#34; for CHARGING, &#34;2&#34; for FULLY_CHARGED, &#34;3&#34; for BATTERY POWERED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_WORKING_MODE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        mode = raw[PROTOCOL_HEADER_SIZE]
        return mode

    def get_button1_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting button 1
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for SHORT_PRESS, &#34;2&#34; for LONG_PRESS, &#34;3&#34; for RELEASED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BUTTON1_STATUS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def get_button2_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting button 2
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for SHORT_PRESS, &#34;2&#34; for LONG_PRESS, &#34;3&#34; for RELEASED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_BUTTON2_STATUS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def set_rtc_time(self, timestamp, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting time of RTC in MCU
        
        Parameters
        -----------
        time : int
            epoch time
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_set_command(command.PROTOCOL_COMMAND_SET_RTC_TIME, timestamp, 4)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_rtc_time(self, format=Definition.TIME_FORMAT_EPOCH, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting time of RTC in MCU
        
        Parameters
        -----------
        format : Definition Object Property
            --&gt; Definition.TIME_FORMAT_EPOCH
            --&gt; Definition.TIME_FORMAT_DATE_AND_TIME
            --&gt; Definition.TIME_FORMAT_DATE
            --&gt; Definition.TIME_FORMAT_TIME
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        timestamp : int/str
            time in chosen format
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_RTC_TIME)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

        timestamp = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
        )

        if format == Definition.TIME_FORMAT_EPOCH:
            return timestamp
        elif format == Definition.TIME_FORMAT_DATE_AND_TIME:
            date_and_time = datetime.datetime.utcfromtimestamp(timestamp).strftime(
                &#34;%Y-%m-%d %H:%M:%S&#34;
            )
            return date_and_time
        elif format == Definition.TIME_FORMAT_DATE:
            date = datetime.datetime.utcfromtimestamp(timestamp).strftime(&#34;%Y-%m-%d&#34;)
            return date
        elif format == Definition.TIME_FORMAT_TIME:
            time = datetime.datetime.utcfromtimestamp(timestamp).strftime(&#34;%H:%M:%S&#34;)
            return time

    def hard_power_off(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for raspberry pi hard powering off
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_HARD_POWER_OFF)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def soft_power_off(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for checking any soft power off request is exist. If any
        request exist, raspberry pi turns off by using &#34;sudo shutdown&#34; terminal
        command in 5 seconds.
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for EXIST, &#34;2&#34; for NOT_EXIST
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_SOFT_POWER_OFF)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)
        result2 = 0
        result = raw[PROTOCOL_HEADER_SIZE]

        if result == Definition.SET_OK:
            command.create_set_command(command.PROTOCOL_COMMAND_SOFT_POWER_OFF, 1, 1)
            command.send_command()
            delay_ms(timeout)
            raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)
            result2 = raw[PROTOCOL_HEADER_SIZE]

            if result2 == Definition.SET_OK:
                print(&#34;Raspberry Pi will shutdown in 5 seconds!&#34;)
                os.system(&#34;sleep 5 &amp;&amp; sudo shutdown -h now&#34;)
                return result2

        return Definition.SET_FAILED

    def hard_reboot(self, timeout=100):
        &#34;&#34;&#34;
        Function for hard rebooting
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_HARD_REBOOT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def soft_reboot(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for checking any soft reboot request is exist. If any
        request exist, raspberry pi reboots by using &#34;sudo reboot&#34; terminal
        command in 5 seconds.
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for EXIST, &#34;2&#34; for NOT_EXIST
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_SOFT_REBOOT)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result2 = 0
        result = raw[PROTOCOL_HEADER_SIZE]

        if result == Definition.SET_OK:
            command.create_set_command(command.PROTOCOL_COMMAND_SOFT_REBOOT, 1, 1)
            command.send_command()
            delay_ms(timeout)
            raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)
            result2 = raw[PROTOCOL_HEADER_SIZE]

            if result2 == Definition.SET_OK:
                print(&#34;Raspberry Pi will shutdown in 5 seconds!&#34;)
                os.system(&#34;sleep 5 &amp;&amp; sudo reboot&#34;)
                return result2

        return Definition.SET_FAILED

    def ask_watchdog_alarm(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for asking watchdog alarm is exist
            
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for EXIST, &#34;2&#34; for NOT_EXIST
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMAMND_WATCHDOG_ALARM)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

        alarm_status = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT16 - 2], &#34;big&#34;
        )
        return alarm_status

    def get_battery_design_capacity(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting battery design capacity
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        capacity : int
            battery design capacity in [mAh]
        &#34;&#34;&#34;
        command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_DESIGN_CAPACITY)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

        capacity = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT16 - 2], &#34;big&#34;
        )
        return capacity

    def set_battery_design_capacity(self, capacity, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting battery design capacity
        
        Parameters
        -----------
        capacity : int
            battery design capacity in [mAh]
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED 
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_BATTERY_DESIGN_CAPACITY, capacity, 2
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status

    def create_scheduled_event(
        self,
        event_id,
        schedule_type,
        repeat,
        time_or_interval,
        interval_type,
        repeat_period,
        action,
        timeout=200,
    ):
        &#34;&#34;&#34;
        Function for creating scheduling event
        
        Parameters
        -----------
        event_id : int 
            id to describe events indivudially

        schedule_type : Definition Object Property
            --&gt; Definition.NO_EVENT
            --&gt; Definition.EVENT_TIME
            --&gt; Definition.EVENT_INTERVAL

        repeat : Definition Object Property
            --&gt; Definition.EVENT_ONE_SHOT
            --&gt; Definition.EVENT_REPEATED

        time_or_interval : int
            daily_epoch_time in seconds or interval (Checkout *Notes for daily_exact_time)

        interval_type : Definition Object Property 
            --&gt; Definition.INTERVAL_TYPE_SEC
            --&gt; Definition.INTERVAL_TYPE_MIN
            --&gt; Definition.INTERVAL_TYPE_HOUR 

        repeat_period : int
            day_factor (Checkout *Notes)

        action : int
            --&gt; &#34;1&#34; for START
            --&gt; &#34;2&#34; for HARD SHUTDOWN
            --&gt; &#34;3&#34; for SOFT SHUTDOWN
            --&gt; &#34;4&#34; for HARD REBOOT
            --&gt; &#34;5&#34; for SOFT REBOOT

         timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Notes
        -----
        1) Calculation of daily_exact_time :
        daily exact_time formula: epoch_time_local % (24*60*60)
        
        daily exact time example: 
        --&gt; Friday, March 27, 2020 11:19:00 PM GMT+03:00
        --&gt; epoch_local = 1585340340 (In this case local : GMT+3)
        --&gt; daily exact_time = 1585340340 % 86400 = 73140
        
        2) Calculation of day_factor                                                             
        [monday] --&gt; Bit 0
        [tuesday] --&gt; Bit 1
        [wednesday] --&gt; Bit 2
        [thursday] --&gt; Bit 3
        [friday] --&gt; Bit 4
        [saturday] --&gt; Bit 5
        [sunday] --&gt; Bit 6
        [RESERVED] --&gt; Bit 7 (Default 0)
                                                     
        Example Calculation for every day : 
        day_factor = 0b01111111 = 127
        
        Example Calculation for (sunday + monday + tuesday) :
        day_factor = 0b01000011 = 67

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED 
        &#34;&#34;&#34;

        value = bytearray()
        value.append(event_id)
        value.append(schedule_type)
        value.append(repeat)
        value.append((time_or_interval &gt;&gt; 24) &amp; 0xFF)
        value.append((time_or_interval &gt;&gt; 16) &amp; 0xFF)
        value.append((time_or_interval &gt;&gt; 8) &amp; 0xFF)
        value.append(time_or_interval &amp; 0xFF)
        value.append(interval_type)
        value.append(repeat_period)
        value.append(action)

        command.create_set_command(
            command.PROTOCOL_COMMAND_CREATE_SCHEDULED_EVENT, value, 10
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def create_scheduled_event_with_event(self, event, timeout=200):
        &#34;&#34;&#34;
        Function for creating scheduling event
        
        Parameters
        -----------
        event : Event Class Object
            instance of Event class
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED 
        &#34;&#34;&#34;

        value = bytearray()
        value.append(event.id)
        value.append(event.schedule_type)
        value.append(event.repeat)
        value.append((event.time_interval &gt;&gt; 24) &amp; 0xFF)
        value.append((event.time_interval &gt;&gt; 16) &amp; 0xFF)
        value.append((event.time_interval &gt;&gt; 8) &amp; 0xFF)
        value.append(event.time_interval &amp; 0xFF)
        value.append(event.interval_type)
        value.append(event.day)
        value.append(event.action)

        command.create_set_command(
            command.PROTOCOL_COMMAND_CREATE_SCHEDULED_EVENT, value, 10
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_scheduled_event_ids(self, timeout=50):
        &#34;&#34;&#34;
        Function for getting scheduled event ids
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        ids : byteArray(10)
            active ids of scheduled events 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_SCHEDULED_EVENT_IDS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

        ids = int.from_bytes(
            raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT16 - 2], &#34;big&#34;
        )
        ids_bytes = bytearray()

        for i in range(10):
            if ids &amp; (1 &lt;&lt; i):
                ids_bytes.append(i + 1)
        return ids_bytes

    def remove_scheduled_event(self, event_id, timeout=200):
        &#34;&#34;&#34;
        Function for removing scheduling event with event id
        
        Parameters
        -----------
        event_id : int
            event id that is required to remove
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_REMOVE_SCHEDULED_EVENT, event_id, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def remove_all_scheduled_events(self, timeout=200):
        &#34;&#34;&#34;
        Function for removing all scheduling events
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_REMOVE_ALL_SCHEDULED_EVENTS)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def get_firmware_ver(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting firmware version on mcu
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        version : char[8] 
            ver [Ex. v1.00.00]
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FIRMWARE_VER)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(15)
        ver = bytearray(8)

        for i in range(8):
            ver[i] = raw[PROTOCOL_HEADER_SIZE + i]

        ver_str = ver.decode(&#34;utf-8&#34;)
        return ver_str

    def update_firmware(self, firmware_file, update_method=0, timeout=25):
        &#34;&#34;&#34;
        Function for updating mcu firmware. Do not make any other api call while update call is running.
        
        Parameters
        -----------
        firmware_file : str
            .bin file path
        update_method : int (optional)
            &#34;0&#34; for boot_mode_update, &#34;1&#34; for firmware_mode_update (default is 0)
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Yields
        ------
        process : int
            Process [%] on every step

        Returns
        ------- 
        result : int
            &#34;1&#34; for SUCCESS, &#34;2&#34; for FAIL
        &#34;&#34;&#34;

        packet_id = 0
        requesting_packet_id = 1
        packet_size = 20

        # Calculate packet count
        f = open(firmware_file, &#34;rb&#34;)
        all_data = f.read()
        leap_packet_size = len(all_data) % packet_size
        packet_count = int(len(all_data) / packet_size) + 1
        
        if leap_packet_size == 0:
             packet_count = int(len(all_data) / packet_size)

        f.close()

        # open file
        f = open(firmware_file, &#34;rb&#34;)
        data = bytes()

        # Clear program storage for saving new program data
        result = self.clear_program_storage()
        # print(&#34;Program Storage Clear Result: &#34; + str(result))
        if result != 1:
            return Definition.SET_FAILED

        last_process = 0  # for process bar

        # choose the update_method
        if update_method == 0:
            self.reset_for_boot_update()
            delay_ms(800)

        # If any data exist
        while data or (packet_id == 0):
            if packet_id != requesting_packet_id:
                data = f.read(packet_size)
                packet_id += 1

            # calculate the process
            process = int((packet_id * 100) / packet_count)
            yielded_value = None

            if process != last_process:
                if yielded_value != process:
                    yielded_value = process
                    yield process

                last_process = process

            # send data to MCU
            if data:
                if packet_id == packet_count:
                    command.create_firmware_update_command(
                        packet_count,
                        requesting_packet_id,
                        data,
                        packet_len=leap_packet_size,
                    )
                    command.send_command()
                    delay_ms(timeout)
                    raw = command.receive_command(COMMAND_SIZE_FOR_INT16)
                else:
                    command.create_firmware_update_command(
                        packet_count, requesting_packet_id, data
                    )
                    command.send_command()
                    delay_ms(timeout)
                    raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

                try:
                    requesting_packet_id = (raw[5] &lt;&lt; 8) | (raw[6] &amp; 0xFF)
                    # print(&#34;Last Packet Read --&gt; &#34; + str(packet_id))
                    # print(&#34;Requesting --&gt; &#34; + str(requesting_packet_id))

                    # if final packet comes
                    if requesting_packet_id == 0xFFFF:
                        print(&#34;Firmware packages are being writen to flash...&#34;)
                        print(&#34;Please wait until the application starts!&#34;)
                        self.reset_mcu()
                        return
                except:
                    raise ValueError(&#34;None Object Exception&#34;)

        # if firmware update doesn&#39;t ended succesfully
        raise RuntimeError(&#34;Unidentified Runtime Exception&#34;)

    def clear_program_storage(self, timeout=500):
        &#34;&#34;&#34;
        Function for clearing firmware storage
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SUCCESS, &#34;2&#34; for FAIL
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_CLEAR_PROGRAM_STORAGE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        result = raw[PROTOCOL_HEADER_SIZE]
        return result

    def reset_mcu(self):
        &#34;&#34;&#34;
        Function for resetting MCU
        
        Parameters
        -----------
        None

        Returns
        ------- 
        None
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_RESET_MCU)
        command.send_command()

    def reset_for_boot_update(self):
        &#34;&#34;&#34;
        Function for resetting MCU and go to boot mode
        
        Parameters
        -----------
        None

        Returns
        ------- 
        None
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_RESET_MCU_FOR_BOOT_UPDATE)
        command.send_command()

    
    def get_lpm_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting low power mode status
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for LPM ENABLED, &#34;2&#34; for LPM DISABLED 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_LOW_POWER_MODE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status


    def get_edm_status(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting easy deployment mode status
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for EDM ENABLED, &#34;2&#34; for EDM DISABLED 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_EASY_DEPLOYMENT_MODE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status


    def set_lpm_status(self, status, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting low power mode status
        
        Parameters
        -----------
        status : int
            &#34;1&#34; for ENABLED, &#34;2&#34; for DISABLED
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_LOW_POWER_MODE, status, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status


    def set_edm_status(self, status, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting easy deployment mode status
        
        Parameters
        -----------
        status : int
            &#34;1&#34; for ENABLED, &#34;2&#34; for DISABLED
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_EASY_DEPLOYMENT_MODE, status, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status
    
    
    def set_fan_mode(self, mode, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for setting fan mode
        
        Parameters
        -----------
        status : int
            &#34;1&#34; for FAN ON MODE, &#34;2&#34; for FAN OFF MODE, &#34;3&#34; for FAN AUTO MODE 
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        result : int
            &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
        &#34;&#34;&#34;

        command.create_set_command(
            command.PROTOCOL_COMMAND_SET_FAN_MODE, mode, 1
        )
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status


    def get_fan_mode(self, timeout=RESPONSE_DELAY):
        &#34;&#34;&#34;
        Function for getting fan mode
        
        Parameters
        -----------
        timeout : int (optional)
            timeout while receiving the response (default is RESPONSE_DELAY)

        Returns
        ------- 
        status : int
            &#34;1&#34; for FAN ON MODE, &#34;2&#34; for FAN OFF MODE, &#34;3&#34; for FAN AUTO MODE 
        &#34;&#34;&#34;

        command.create_command(command.PROTOCOL_COMMAND_GET_FAN_MODE)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

        status = raw[PROTOCOL_HEADER_SIZE]
        return status</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="power_api.power_api.SixfabPower.board"><code class="name">var <span class="ident">board</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="power_api.power_api.SixfabPower.ask_watchdog_alarm"><code class="name flex">
<span>def <span class="ident">ask_watchdog_alarm</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for asking watchdog alarm is exist</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for EXIST, "2" for NOT_EXIST</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ask_watchdog_alarm(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for asking watchdog alarm is exist
        
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for EXIST, &#34;2&#34; for NOT_EXIST
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMAMND_WATCHDOG_ALARM)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

    alarm_status = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT16 - 2], &#34;big&#34;
    )
    return alarm_status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.clear_program_storage"><code class="name flex">
<span>def <span class="ident">clear_program_storage</span></span>(<span>self, timeout=500)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for clearing firmware storage</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SUCCESS, "2" for FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_program_storage(self, timeout=500):
    &#34;&#34;&#34;
    Function for clearing firmware storage
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SUCCESS, &#34;2&#34; for FAIL
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_CLEAR_PROGRAM_STORAGE)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.create_scheduled_event"><code class="name flex">
<span>def <span class="ident">create_scheduled_event</span></span>(<span>self, event_id, schedule_type, repeat, time_or_interval, interval_type, repeat_period, action, timeout=200)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for creating scheduling event</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_id</code></strong> :&ensp;<code>int </code></dt>
<dd>id to describe events indivudially</dd>
<dt><strong><code>schedule_type</code></strong> :&ensp;<code>Definition Object Property</code></dt>
<dd>&ndash;&gt; Definition.NO_EVENT
&ndash;&gt; Definition.EVENT_TIME
&ndash;&gt; Definition.EVENT_INTERVAL</dd>
<dt><strong><code>repeat</code></strong> :&ensp;<code>Definition Object Property</code></dt>
<dd>&ndash;&gt; Definition.EVENT_ONE_SHOT
&ndash;&gt; Definition.EVENT_REPEATED</dd>
<dt><strong><code>time_or_interval</code></strong> :&ensp;<code>int</code></dt>
<dd>daily_epoch_time in seconds or interval (Checkout *Notes for daily_exact_time)</dd>
<dt><strong><code>interval_type</code></strong> :&ensp;<code>Definition Object Property </code></dt>
<dd>&ndash;&gt; Definition.INTERVAL_TYPE_SEC
&ndash;&gt; Definition.INTERVAL_TYPE_MIN
&ndash;&gt; Definition.INTERVAL_TYPE_HOUR</dd>
<dt><strong><code>repeat_period</code></strong> :&ensp;<code>int</code></dt>
<dd>day_factor (Checkout *Notes)</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>int</code></dt>
<dd>&ndash;&gt; "1" for START
&ndash;&gt; "2" for HARD SHUTDOWN
&ndash;&gt; "3" for SOFT SHUTDOWN
&ndash;&gt; "4" for HARD REBOOT
&ndash;&gt; "5" for SOFT REBOOT</dd>
</dl>
<p>timeout : int (optional)
timeout while receiving the response (default is RESPONSE_DELAY)</p>
<h2 id="notes">Notes</h2>
<p>1) Calculation of daily_exact_time :
daily exact_time formula: epoch_time_local % (24<em>60</em>60)</p>
<p>daily exact time example:
&ndash;&gt; Friday, March 27, 2020 11:19:00 PM GMT+03:00
&ndash;&gt; epoch_local = 1585340340 (In this case local : GMT+3)
&ndash;&gt; daily exact_time = 1585340340 % 86400 = 73140</p>
<p>2) Calculation of day_factor
<br>
[monday] &ndash;&gt; Bit 0
[tuesday] &ndash;&gt; Bit 1
[wednesday] &ndash;&gt; Bit 2
[thursday] &ndash;&gt; Bit 3
[friday] &ndash;&gt; Bit 4
[saturday] &ndash;&gt; Bit 5
[sunday] &ndash;&gt; Bit 6
[RESERVED] &ndash;&gt; Bit 7 (Default 0)</p>
<p>Example Calculation for every day :
day_factor = 0b01111111 = 127</p>
<p>Example Calculation for (sunday + monday + tuesday) :
day_factor = 0b01000011 = 67</p>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET_OK, "2" for SET_FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_scheduled_event(
    self,
    event_id,
    schedule_type,
    repeat,
    time_or_interval,
    interval_type,
    repeat_period,
    action,
    timeout=200,
):
    &#34;&#34;&#34;
    Function for creating scheduling event
    
    Parameters
    -----------
    event_id : int 
        id to describe events indivudially

    schedule_type : Definition Object Property
        --&gt; Definition.NO_EVENT
        --&gt; Definition.EVENT_TIME
        --&gt; Definition.EVENT_INTERVAL

    repeat : Definition Object Property
        --&gt; Definition.EVENT_ONE_SHOT
        --&gt; Definition.EVENT_REPEATED

    time_or_interval : int
        daily_epoch_time in seconds or interval (Checkout *Notes for daily_exact_time)

    interval_type : Definition Object Property 
        --&gt; Definition.INTERVAL_TYPE_SEC
        --&gt; Definition.INTERVAL_TYPE_MIN
        --&gt; Definition.INTERVAL_TYPE_HOUR 

    repeat_period : int
        day_factor (Checkout *Notes)

    action : int
        --&gt; &#34;1&#34; for START
        --&gt; &#34;2&#34; for HARD SHUTDOWN
        --&gt; &#34;3&#34; for SOFT SHUTDOWN
        --&gt; &#34;4&#34; for HARD REBOOT
        --&gt; &#34;5&#34; for SOFT REBOOT

     timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Notes
    -----
    1) Calculation of daily_exact_time :
    daily exact_time formula: epoch_time_local % (24*60*60)
    
    daily exact time example: 
    --&gt; Friday, March 27, 2020 11:19:00 PM GMT+03:00
    --&gt; epoch_local = 1585340340 (In this case local : GMT+3)
    --&gt; daily exact_time = 1585340340 % 86400 = 73140
    
    2) Calculation of day_factor                                                             
    [monday] --&gt; Bit 0
    [tuesday] --&gt; Bit 1
    [wednesday] --&gt; Bit 2
    [thursday] --&gt; Bit 3
    [friday] --&gt; Bit 4
    [saturday] --&gt; Bit 5
    [sunday] --&gt; Bit 6
    [RESERVED] --&gt; Bit 7 (Default 0)
                                                 
    Example Calculation for every day : 
    day_factor = 0b01111111 = 127
    
    Example Calculation for (sunday + monday + tuesday) :
    day_factor = 0b01000011 = 67

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED 
    &#34;&#34;&#34;

    value = bytearray()
    value.append(event_id)
    value.append(schedule_type)
    value.append(repeat)
    value.append((time_or_interval &gt;&gt; 24) &amp; 0xFF)
    value.append((time_or_interval &gt;&gt; 16) &amp; 0xFF)
    value.append((time_or_interval &gt;&gt; 8) &amp; 0xFF)
    value.append(time_or_interval &amp; 0xFF)
    value.append(interval_type)
    value.append(repeat_period)
    value.append(action)

    command.create_set_command(
        command.PROTOCOL_COMMAND_CREATE_SCHEDULED_EVENT, value, 10
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.create_scheduled_event_with_event"><code class="name flex">
<span>def <span class="ident">create_scheduled_event_with_event</span></span>(<span>self, event, timeout=200)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for creating scheduling event</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>Event Class Object</code></dt>
<dd>instance of Event class</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET_OK, "2" for SET_FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_scheduled_event_with_event(self, event, timeout=200):
    &#34;&#34;&#34;
    Function for creating scheduling event
    
    Parameters
    -----------
    event : Event Class Object
        instance of Event class
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED 
    &#34;&#34;&#34;

    value = bytearray()
    value.append(event.id)
    value.append(event.schedule_type)
    value.append(event.repeat)
    value.append((event.time_interval &gt;&gt; 24) &amp; 0xFF)
    value.append((event.time_interval &gt;&gt; 16) &amp; 0xFF)
    value.append((event.time_interval &gt;&gt; 8) &amp; 0xFF)
    value.append(event.time_interval &amp; 0xFF)
    value.append(event.interval_type)
    value.append(event.day)
    value.append(event.action)

    command.create_set_command(
        command.PROTOCOL_COMMAND_CREATE_SCHEDULED_EVENT, value, 10
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_battery_current"><code class="name flex">
<span>def <span class="ident">get_battery_current</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting battery current</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>current : float
battery current [Ampere]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_current(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting battery current
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    current : float
        battery current [Ampere]
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_CURRENT)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    current = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;, signed=True
    )
    return current / 1000</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_battery_design_capacity"><code class="name flex">
<span>def <span class="ident">get_battery_design_capacity</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting battery design capacity</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>capacity : int
battery design capacity in [mAh]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_design_capacity(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting battery design capacity
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    capacity : int
        battery design capacity in [mAh]
    &#34;&#34;&#34;
    command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_DESIGN_CAPACITY)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

    capacity = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT16 - 2], &#34;big&#34;
    )
    return capacity</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_battery_health"><code class="name flex">
<span>def <span class="ident">get_battery_health</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting battery health</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>health : int
battery health as percentage [%]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_health(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting battery health
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    health : int
        battery health as percentage [%] 
    &#34;&#34;&#34;
    command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_HEALTH)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    health = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return health</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_battery_level"><code class="name flex">
<span>def <span class="ident">get_battery_level</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting battery level</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>level : int
battery charge of state as percentage [%]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_level(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting battery level
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    level : int
        battery charge of state as percentage [%]
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_LEVEL)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    level = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return level</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_battery_max_charge_level"><code class="name flex">
<span>def <span class="ident">get_battery_max_charge_level</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting battery max charge level</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>level : int
battery max charge level in percentage [%]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_max_charge_level(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting battery max charge level
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    level : int
        battery max charge level in percentage [%]
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_MAX_CHARGE_LEVEL)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    level = raw[PROTOCOL_HEADER_SIZE]
    return level</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_battery_power"><code class="name flex">
<span>def <span class="ident">get_battery_power</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting battery power</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>power : float
battery power [Watt]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_power(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting battery power
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    power : float
        battery power [Watt]
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_POWER)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    power = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;, signed=True
    )
    return power / 1000</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_battery_temp"><code class="name flex">
<span>def <span class="ident">get_battery_temp</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting battery temperature</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>temperature : float
battery temperature [Celcius]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_temp(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting battery temperature
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    temperature : float
        battery temperature [Celcius]
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_TEMP)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    temp = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return temp / 100</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_battery_voltage"><code class="name flex">
<span>def <span class="ident">get_battery_voltage</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting battery voltage</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>voltage : float
battery voltage [Volt]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_battery_voltage(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting battery voltage
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    voltage : float 
        battery voltage [Volt]
    &#34;&#34;&#34;
    command.create_command(command.PROTOCOL_COMMAND_GET_BATTERY_VOLTAGE)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    voltage = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return voltage / 1000</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_button1_status"><code class="name flex">
<span>def <span class="ident">get_button1_status</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting button 1</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>status : int
"1" for SHORT_PRESS, "2" for LONG_PRESS, "3" for RELEASED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_button1_status(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting button 1
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    status : int
        &#34;1&#34; for SHORT_PRESS, &#34;2&#34; for LONG_PRESS, &#34;3&#34; for RELEASED
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_BUTTON1_STATUS)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_button2_status"><code class="name flex">
<span>def <span class="ident">get_button2_status</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting button 2</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>status : int
"1" for SHORT_PRESS, "2" for LONG_PRESS, "3" for RELEASED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_button2_status(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting button 2
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    status : int
        &#34;1&#34; for SHORT_PRESS, &#34;2&#34; for LONG_PRESS, &#34;3&#34; for RELEASED
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_BUTTON2_STATUS)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_edm_status"><code class="name flex">
<span>def <span class="ident">get_edm_status</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting easy deployment mode status</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>status : int
"1" for EDM ENABLED, "2" for EDM DISABLED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edm_status(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting easy deployment mode status
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    status : int
        &#34;1&#34; for EDM ENABLED, &#34;2&#34; for EDM DISABLED 
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_EASY_DEPLOYMENT_MODE)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_fan_automation"><code class="name flex">
<span>def <span class="ident">get_fan_automation</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting fan automation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>automation : byteArray(2)
[slow_threshold, fast_threshold] [Celcius]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fan_automation(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting fan automation
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    automation : byteArray(2) 
        [slow_threshold, fast_threshold] [Celcius]
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_FAN_AUTOMATION)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(9)

    fanAutomation = bytearray()
    for i in range(2):
        fanAutomation.append(raw[PROTOCOL_HEADER_SIZE + i])

    return fanAutomation</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_fan_health"><code class="name flex">
<span>def <span class="ident">get_fan_health</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting fan health</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>health : int
"1" for HEALTHY, "2" for BROKEN</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fan_health(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting fan health
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    health : int
        &#34;1&#34; for HEALTHY, &#34;2&#34; for BROKEN
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_FAN_HEALTH)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    health = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return health</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_fan_mode"><code class="name flex">
<span>def <span class="ident">get_fan_mode</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting fan mode</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>status : int
"1" for FAN ON MODE, "2" for FAN OFF MODE, "3" for FAN AUTO MODE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fan_mode(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting fan mode
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    status : int
        &#34;1&#34; for FAN ON MODE, &#34;2&#34; for FAN OFF MODE, &#34;3&#34; for FAN AUTO MODE 
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_FAN_MODE)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_fan_speed"><code class="name flex">
<span>def <span class="ident">get_fan_speed</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting fan speed</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>speed : int
fan speed [RPM]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fan_speed(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting fan speed
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    speed : int
        fan speed [RPM] 
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_FAN_SPEED)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    rpm = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return rpm</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_firmware_ver"><code class="name flex">
<span>def <span class="ident">get_firmware_ver</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting firmware version on mcu</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>version : char[8]
ver [Ex. v1.00.00]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_firmware_ver(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting firmware version on mcu
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    version : char[8] 
        ver [Ex. v1.00.00]
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_FIRMWARE_VER)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(15)
    ver = bytearray(8)

    for i in range(8):
        ver[i] = raw[PROTOCOL_HEADER_SIZE + i]

    ver_str = ver.decode(&#34;utf-8&#34;)
    return ver_str</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_input_current"><code class="name flex">
<span>def <span class="ident">get_input_current</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting input current</p>
<h2 id="parameters">Parameters</h2>
<p>timeout : int (optional)
timeout while receiving the response (default is RESPONSE_DELAY)</p>
<h2 id="returns">Returns</h2>
<p>current : float
input current [Ampere]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_current(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting input current
    
    Parameters
    -----------                     
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    current : float 
        input current [Ampere] 
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_CURRENT)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    current = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return current / 1000</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_input_power"><code class="name flex">
<span>def <span class="ident">get_input_power</span></span>(<span>self, timeout=50)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting input power</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>power : float
input power [Watt]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_power(self, timeout=50):
    &#34;&#34;&#34;
    Function for getting input power
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    power : float
        input power [Watt] 
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_POWER)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    power = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return power / 1000</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_input_temp"><code class="name flex">
<span>def <span class="ident">get_input_temp</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting input temperature</p>
<h2 id="parameters">Parameters</h2>
<p>timeout : int (optional)
timeout while receiving the response (default is RESPONSE_DELAY)</p>
<h2 id="returns">Returns</h2>
<p>temperature : float
PCB temperature of Sixfab Power Management and UPS HAT [Celcius]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_temp(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;Function for getting input temperature
    
    Parameters
    -----------             
    timeout : int (optional)
    timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    temperature : float 
    PCB temperature of Sixfab Power Management and UPS HAT [Celcius]  
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_TEMP)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    temp = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return temp / 100</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_input_voltage"><code class="name flex">
<span>def <span class="ident">get_input_voltage</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting input voltage</p>
<h2 id="parameters">Parameters</h2>
<p>timeout : int (optional)
timeout while receiving the response (default is RESPONSE_DELAY)</p>
<h2 id="returns">Returns</h2>
<p>voltage : float
input voltage [Volt]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_voltage(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting input voltage
    
    Parameters
    -----------     
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    voltage : float 
        input voltage [Volt] 
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_INPUT_VOLTAGE)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    voltage = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return voltage / 1000</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_lpm_status"><code class="name flex">
<span>def <span class="ident">get_lpm_status</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting low power mode status</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>status : int
"1" for LPM ENABLED, "2" for LPM DISABLED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lpm_status(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting low power mode status
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    status : int
        &#34;1&#34; for LPM ENABLED, &#34;2&#34; for LPM DISABLED 
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_LOW_POWER_MODE)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_rgb_animation"><code class="name flex">
<span>def <span class="ident">get_rgb_animation</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting RGB animation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>animation : byteArray(3)
[anim_type, color, speed]</p>
<h2 id="notes">Notes</h2>
<p>anim_type : Definition Object Property
&ndash;&gt; Definition.RGB_DISABLED
&ndash;&gt; Definition.RGB_HEARTBEAT
&ndash;&gt; Definition.RGB_TEMP_MAP</p>
<p>color : Definition Object Property
&ndash;&gt; Definition.RED
&ndash;&gt; Definition.GREEN
&ndash;&gt; Definition.BLUE
&ndash;&gt; Definition.YELLOW
&ndash;&gt; Definition.CYAN
&ndash;&gt; Definition.MAGENTA
&ndash;&gt; Definition.WHITE
&ndash;&gt; Definition.BLACK</p>
<p>speed : Definition Object Property
&ndash;&gt; Definition.SLOW
&ndash;&gt; Definition.NORMAL
&ndash;&gt; Definition.FAST</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rgb_animation(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting RGB animation
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    animation : byteArray(3)
        [anim_type, color, speed]

    Notes
    -----
    anim_type : Definition Object Property
        --&gt; Definition.RGB_DISABLED
        --&gt; Definition.RGB_HEARTBEAT
        --&gt; Definition.RGB_TEMP_MAP

    color : Definition Object Property
        --&gt; Definition.RED
        --&gt; Definition.GREEN
        --&gt; Definition.BLUE
        --&gt; Definition.YELLOW
        --&gt; Definition.CYAN
        --&gt; Definition.MAGENTA
        --&gt; Definition.WHITE
        --&gt; Definition.BLACK
    
    speed : Definition Object Property
        --&gt; Definition.SLOW
        --&gt; Definition.NORMAL
        --&gt; Definition.FAST
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_RGB_ANIMATION)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(10)

    animation = bytearray()
    for i in range(3):
        animation.append(raw[PROTOCOL_HEADER_SIZE + i])

    return animation</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_rtc_time"><code class="name flex">
<span>def <span class="ident">get_rtc_time</span></span>(<span>self, format=0, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting time of RTC in MCU</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>Definition Object Property</code></dt>
<dd>&ndash;&gt; Definition.TIME_FORMAT_EPOCH
&ndash;&gt; Definition.TIME_FORMAT_DATE_AND_TIME
&ndash;&gt; Definition.TIME_FORMAT_DATE
&ndash;&gt; Definition.TIME_FORMAT_TIME</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>timestamp : int/str
time in chosen format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rtc_time(self, format=Definition.TIME_FORMAT_EPOCH, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting time of RTC in MCU
    
    Parameters
    -----------
    format : Definition Object Property
        --&gt; Definition.TIME_FORMAT_EPOCH
        --&gt; Definition.TIME_FORMAT_DATE_AND_TIME
        --&gt; Definition.TIME_FORMAT_DATE
        --&gt; Definition.TIME_FORMAT_TIME
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    timestamp : int/str
        time in chosen format
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_RTC_TIME)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    timestamp = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )

    if format == Definition.TIME_FORMAT_EPOCH:
        return timestamp
    elif format == Definition.TIME_FORMAT_DATE_AND_TIME:
        date_and_time = datetime.datetime.utcfromtimestamp(timestamp).strftime(
            &#34;%Y-%m-%d %H:%M:%S&#34;
        )
        return date_and_time
    elif format == Definition.TIME_FORMAT_DATE:
        date = datetime.datetime.utcfromtimestamp(timestamp).strftime(&#34;%Y-%m-%d&#34;)
        return date
    elif format == Definition.TIME_FORMAT_TIME:
        time = datetime.datetime.utcfromtimestamp(timestamp).strftime(&#34;%H:%M:%S&#34;)
        return time</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_safe_shutdown_battery_level"><code class="name flex">
<span>def <span class="ident">get_safe_shutdown_battery_level</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting safe shutdown battery level</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>level : int
safe shutdown level in percentage [%]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_safe_shutdown_battery_level(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting safe shutdown battery level
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    level : int
        safe shutdown level in percentage [%]
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_SAFE_SHUTDOWN_BATTERY_LEVEL)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    level = raw[PROTOCOL_HEADER_SIZE]
    return level</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_safe_shutdown_status"><code class="name flex">
<span>def <span class="ident">get_safe_shutdown_status</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting safe shutdown status</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>status : int
"1" for ENABLEDi "2" for DISABLED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_safe_shutdown_status(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting safe shutdown status
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    status : int
        &#34;1&#34; for ENABLEDi &#34;2&#34; for DISABLED
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_SAFE_SHUTDOWN_STATUS)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_scheduled_event_ids"><code class="name flex">
<span>def <span class="ident">get_scheduled_event_ids</span></span>(<span>self, timeout=50)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting scheduled event ids</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ids : byteArray(10)
active ids of scheduled events</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scheduled_event_ids(self, timeout=50):
    &#34;&#34;&#34;
    Function for getting scheduled event ids
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    ids : byteArray(10)
        active ids of scheduled events 
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_SCHEDULED_EVENT_IDS)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

    ids = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT16 - 2], &#34;big&#34;
    )
    ids_bytes = bytearray()

    for i in range(10):
        if ids &amp; (1 &lt;&lt; i):
            ids_bytes.append(i + 1)
    return ids_bytes</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_system_current"><code class="name flex">
<span>def <span class="ident">get_system_current</span></span>(<span>self, timeout=50)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting system current</p>
<h2 id="parameters">Parameters</h2>
<p>timeout : int (optional)
timeout while receiving the response (default is RESPONSE_DELAY)</p>
<h2 id="returns">Returns</h2>
<p>current : float
current that supplies raspberry pi and other peripherals [Ampere]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_current(self, timeout=50):
    &#34;&#34;&#34;
    Function for getting system current
    
    Parameters
    -----------     
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    current : float
        current that supplies raspberry pi and other peripherals [Ampere]
    &#34;&#34;&#34;
    command.create_command(command.PROTOCOL_COMMAND_GET_SYSTEM_CURRENT)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    current = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return current / 1000</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_system_power"><code class="name flex">
<span>def <span class="ident">get_system_power</span></span>(<span>self, timeout=50)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting system power</p>
<h2 id="parameters">Parameters</h2>
<p>timeout : int (optional)
timeout while receiving the response (default is RESPONSE_DELAY)</p>
<h2 id="returns">Returns</h2>
<p>power : float
power that supplies raspberry pi and other peripherals [Ampere]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_power(self, timeout=50):
    &#34;&#34;&#34;
    Function for getting system power
    
    Parameters
    -----------     
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    power : float
        power that supplies raspberry pi and other peripherals [Ampere]
    &#34;&#34;&#34;
    command.create_command(command.PROTOCOL_COMMAND_GET_SYSTEM_POWER)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    power = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return power / 1000</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_system_temp"><code class="name flex">
<span>def <span class="ident">get_system_temp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting raspberry pi core temperature</p>
<h2 id="parameters">Parameters</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>temperature : float
raspberry pi core temperature [Celcius]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_temp(self):
    &#34;&#34;&#34;
    Function for getting raspberry pi core temperature
    
    Parameters
    -----------     
    None

    Returns
    ------- 
    temperature : float
        raspberry pi core temperature [Celcius] 
    &#34;&#34;&#34;
    temp = os.popen(&#34;vcgencmd measure_temp&#34;).readline()
    temp = temp.replace(&#34;temp=&#34;, &#34;&#34;)
    return float(temp[:-3])</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_system_voltage"><code class="name flex">
<span>def <span class="ident">get_system_voltage</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting system voltage</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>voltage : float
voltage source that supplies raspberry pi and other peripherals [Volt]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_voltage(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting system voltage
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    voltage : float
        voltage source that supplies raspberry pi and other peripherals [Volt]
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_SYSTEM_VOLTAGE)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_INT32)

    voltage = int.from_bytes(
        raw[PROTOCOL_HEADER_SIZE : COMMAND_SIZE_FOR_INT32 - 2], &#34;big&#34;
    )
    return voltage / 1000</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_watchdog_status"><code class="name flex">
<span>def <span class="ident">get_watchdog_status</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting watchdog status</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>status : int
"1" for WATCHDOG ENABLED, "2" for WATCHDOG DISABLED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_watchdog_status(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting watchdog status
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    status : int
        &#34;1&#34; for WATCHDOG ENABLED, &#34;2&#34; for WATCHDOG DISABLED 
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_WATCHDOG_STATUS)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.get_working_mode"><code class="name flex">
<span>def <span class="ident">get_working_mode</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for getting working mode</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>working_mode : int
"1" for CHARGING, "2" for FULLY_CHARGED, "3" for BATTERY POWERED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_working_mode(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for getting working mode
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    working_mode : int
        &#34;1&#34; for CHARGING, &#34;2&#34; for FULLY_CHARGED, &#34;3&#34; for BATTERY POWERED
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_GET_WORKING_MODE)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    mode = raw[PROTOCOL_HEADER_SIZE]
    return mode</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.hard_power_off"><code class="name flex">
<span>def <span class="ident">hard_power_off</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for raspberry pi hard powering off</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET_OK, "2" for SET_FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hard_power_off(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for raspberry pi hard powering off
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_HARD_POWER_OFF)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.hard_reboot"><code class="name flex">
<span>def <span class="ident">hard_reboot</span></span>(<span>self, timeout=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for hard rebooting</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" SET_OK, "2" for SET_FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hard_reboot(self, timeout=100):
    &#34;&#34;&#34;
    Function for hard rebooting
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; SET_OK, &#34;2&#34; for SET_FAILED
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_HARD_REBOOT)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.remove_all_scheduled_events"><code class="name flex">
<span>def <span class="ident">remove_all_scheduled_events</span></span>(<span>self, timeout=200)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for removing all scheduling events</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET_OK, "2" for SET_FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_all_scheduled_events(self, timeout=200):
    &#34;&#34;&#34;
    Function for removing all scheduling events
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_REMOVE_ALL_SCHEDULED_EVENTS)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.remove_scheduled_event"><code class="name flex">
<span>def <span class="ident">remove_scheduled_event</span></span>(<span>self, event_id, timeout=200)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for removing scheduling event with event id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_id</code></strong> :&ensp;<code>int</code></dt>
<dd>event id that is required to remove</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET_OK, "2" for SET_FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_scheduled_event(self, event_id, timeout=200):
    &#34;&#34;&#34;
    Function for removing scheduling event with event id
    
    Parameters
    -----------
    event_id : int
        event id that is required to remove
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
    &#34;&#34;&#34;

    command.create_set_command(
        command.PROTOCOL_COMMAND_REMOVE_SCHEDULED_EVENT, event_id, 1
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.reset_for_boot_update"><code class="name flex">
<span>def <span class="ident">reset_for_boot_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for resetting MCU and go to boot mode</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_for_boot_update(self):
    &#34;&#34;&#34;
    Function for resetting MCU and go to boot mode
    
    Parameters
    -----------
    None

    Returns
    ------- 
    None
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_RESET_MCU_FOR_BOOT_UPDATE)
    command.send_command()</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.reset_mcu"><code class="name flex">
<span>def <span class="ident">reset_mcu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for resetting MCU</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_mcu(self):
    &#34;&#34;&#34;
    Function for resetting MCU
    
    Parameters
    -----------
    None

    Returns
    ------- 
    None
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_RESET_MCU)
    command.send_command()</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.send_system_temp"><code class="name flex">
<span>def <span class="ident">send_system_temp</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for sending raspberry pi core temperature to mcu</p>
<h2 id="parameters">Parameters</h2>
<p>timeout : int (optional)
timeout while receiving the response (default is RESPONSE_DELAY)</p>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SUCCESS, "2" for FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_system_temp(self, timeout=10):
    &#34;&#34;&#34;
    Function for sending raspberry pi core temperature to mcu
    
    Parameters
    -----------     
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SUCCESS, &#34;2&#34; for FAIL
    &#34;&#34;&#34;

    temp = self.get_system_temp()
    tempInt = int(temp * 100)

    command.create_set_command(command.PROTOCOL_COMMAND_GET_SYSTEM_TEMP, tempInt, 4)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_battery_design_capacity"><code class="name flex">
<span>def <span class="ident">set_battery_design_capacity</span></span>(<span>self, capacity, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting battery design capacity</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>capacity</code></strong> :&ensp;<code>int</code></dt>
<dd>battery design capacity in [mAh]</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET_OK, "2" for SET_FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_battery_design_capacity(self, capacity, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting battery design capacity
    
    Parameters
    -----------
    capacity : int
        battery design capacity in [mAh]
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED 
    &#34;&#34;&#34;

    command.create_set_command(
        command.PROTOCOL_COMMAND_SET_BATTERY_DESIGN_CAPACITY, capacity, 2
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_battery_max_charge_level"><code class="name flex">
<span>def <span class="ident">set_battery_max_charge_level</span></span>(<span>self, level, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting battery max charge level</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>battery is charged up to this level in percentage [%]</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET OK, "2" for SET FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_battery_max_charge_level(self, level, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting battery max charge level
    
    Parameters
    -----------
    level : int
        battery is charged up to this level in percentage [%]
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
    &#34;&#34;&#34;

    command.create_set_command(
        command.PROTOCOL_COMMAND_SET_BATTERY_MAX_CHARGE_LEVEL, level, 1
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    level = raw[PROTOCOL_HEADER_SIZE]
    return level</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_edm_status"><code class="name flex">
<span>def <span class="ident">set_edm_status</span></span>(<span>self, status, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting easy deployment mode status</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>int</code></dt>
<dd>"1" for ENABLED, "2" for DISABLED</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET OK, "2" for SET FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edm_status(self, status, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting easy deployment mode status
    
    Parameters
    -----------
    status : int
        &#34;1&#34; for ENABLED, &#34;2&#34; for DISABLED
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
    &#34;&#34;&#34;

    command.create_set_command(
        command.PROTOCOL_COMMAND_SET_EASY_DEPLOYMENT_MODE, status, 1
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_fan_automation"><code class="name flex">
<span>def <span class="ident">set_fan_automation</span></span>(<span>self, slow_threshold, fast_threshold=100, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting fan automation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>slow_threshold</code></strong> :&ensp;<code>int</code></dt>
<dd>temperature threshold to decide fan working status</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET OK, "2" for SET FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fan_automation(
    self, slow_threshold, fast_threshold=100, timeout=RESPONSE_DELAY
):
    &#34;&#34;&#34;
    Function for setting fan automation
    
    Parameters
    -----------
    slow_threshold : int
        temperature threshold to decide fan working status
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED 
    &#34;&#34;&#34;

    value = bytearray()
    value.append(int(slow_threshold))
    value.append(int(fast_threshold))

    command.create_set_command(
        command.PROTOCOL_COMMAND_SET_FAN_AUTOMATION, value, 2
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_fan_mode"><code class="name flex">
<span>def <span class="ident">set_fan_mode</span></span>(<span>self, mode, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting fan mode</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>int</code></dt>
<dd>"1" for FAN ON MODE, "2" for FAN OFF MODE, "3" for FAN AUTO MODE</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET OK, "2" for SET FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fan_mode(self, mode, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting fan mode
    
    Parameters
    -----------
    status : int
        &#34;1&#34; for FAN ON MODE, &#34;2&#34; for FAN OFF MODE, &#34;3&#34; for FAN AUTO MODE 
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
    &#34;&#34;&#34;

    command.create_set_command(
        command.PROTOCOL_COMMAND_SET_FAN_MODE, mode, 1
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_lpm_status"><code class="name flex">
<span>def <span class="ident">set_lpm_status</span></span>(<span>self, status, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting low power mode status</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>int</code></dt>
<dd>"1" for ENABLED, "2" for DISABLED</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET OK, "2" for SET FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_lpm_status(self, status, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting low power mode status
    
    Parameters
    -----------
    status : int
        &#34;1&#34; for ENABLED, &#34;2&#34; for DISABLED
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
    &#34;&#34;&#34;

    command.create_set_command(
        command.PROTOCOL_COMMAND_SET_LOW_POWER_MODE, status, 1
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_rgb_animation"><code class="name flex">
<span>def <span class="ident">set_rgb_animation</span></span>(<span>self, anim_type, color, speed, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting RGB animation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>anim_type</code></strong> :&ensp;<code>[DISABLED, HEARTBEAT, TEMP_MAP]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>[GREEN, BLUE, RED, YELLOW, CYAN, MAGENTA, WHITE]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>speed</code></strong> :&ensp;<code>[SLOW, NORMAL, FAST] </code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET OK, "2" for SET FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rgb_animation(self, anim_type, color, speed, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting RGB animation
    
    Parameters
    -----------
    anim_type : [DISABLED, HEARTBEAT, TEMP_MAP]
    color : [GREEN, BLUE, RED, YELLOW, CYAN, MAGENTA, WHITE]
    speed : [SLOW, NORMAL, FAST] 
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED 
    &#34;&#34;&#34;

    value = bytearray()
    value.append(int(anim_type))
    value.append(int(color))
    value.append(int(speed))

    command.create_set_command(command.PROTOCOL_COMMAND_SET_RGB_ANIMATION, value, 3)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_rtc_time"><code class="name flex">
<span>def <span class="ident">set_rtc_time</span></span>(<span>self, timestamp, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting time of RTC in MCU</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>int</code></dt>
<dd>epoch time</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET_OK, "2" for SET_FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rtc_time(self, timestamp, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting time of RTC in MCU
    
    Parameters
    -----------
    time : int
        epoch time
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET_OK, &#34;2&#34; for SET_FAILED
    &#34;&#34;&#34;

    command.create_set_command(command.PROTOCOL_COMMAND_SET_RTC_TIME, timestamp, 4)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_safe_shutdown_battery_level"><code class="name flex">
<span>def <span class="ident">set_safe_shutdown_battery_level</span></span>(<span>self, level, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting safe shutdown battery level</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>raspberry pi is turned off if battery falls to this level</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET OK, "2" for SET FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_safe_shutdown_battery_level(self, level, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting safe shutdown battery level
    
    Parameters
    -----------
    level : int
        raspberry pi is turned off if battery falls to this level
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
    &#34;&#34;&#34;

    command.create_set_command(
        command.PROTOCOL_COMMAND_SET_SAFE_SHUTDOWN_BATTERY_LEVEL, level, 1
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    level = raw[PROTOCOL_HEADER_SIZE]
    return level</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_safe_shutdown_status"><code class="name flex">
<span>def <span class="ident">set_safe_shutdown_status</span></span>(<span>self, status, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting safe shutdown status</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>int</code></dt>
<dd>"1" for ENABLED, "2" for DISABLED</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET OK, "2" for SET FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_safe_shutdown_status(self, status, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting safe shutdown status
    
    Parameters
    -----------
    status : int
        &#34;1&#34; for ENABLED, &#34;2&#34; for DISABLED
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED
    &#34;&#34;&#34;

    command.create_set_command(
        command.PROTOCOL_COMMAND_SET_SAFE_SHUTDOWN_STATUS, status, 1
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    status = raw[PROTOCOL_HEADER_SIZE]
    return status</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.set_watchdog_status"><code class="name flex">
<span>def <span class="ident">set_watchdog_status</span></span>(<span>self, status, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for setting watchdog status</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>"1" for WATCHDOG ENABLED, "2" for WATCHDOG DISABLED</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SET OK, "2" for SET FAILED</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_watchdog_status(self, status, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for setting watchdog status
    
    Parameters
    -----------
    status : &#34;1&#34; for WATCHDOG ENABLED, &#34;2&#34; for WATCHDOG DISABLED
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for SET OK, &#34;2&#34; for SET FAILED 
    &#34;&#34;&#34;

    command.create_set_command(
        command.PROTOCOL_COMMAND_SET_WATCHDOG_STATUS, status, 1
    )
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result = raw[PROTOCOL_HEADER_SIZE]
    return result</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.soft_power_off"><code class="name flex">
<span>def <span class="ident">soft_power_off</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for checking any soft power off request is exist. If any
request exist, raspberry pi turns off by using "sudo shutdown" terminal
command in 5 seconds.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for EXIST, "2" for NOT_EXIST</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soft_power_off(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for checking any soft power off request is exist. If any
    request exist, raspberry pi turns off by using &#34;sudo shutdown&#34; terminal
    command in 5 seconds.
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for EXIST, &#34;2&#34; for NOT_EXIST
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_SOFT_POWER_OFF)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)
    result2 = 0
    result = raw[PROTOCOL_HEADER_SIZE]

    if result == Definition.SET_OK:
        command.create_set_command(command.PROTOCOL_COMMAND_SOFT_POWER_OFF, 1, 1)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)
        result2 = raw[PROTOCOL_HEADER_SIZE]

        if result2 == Definition.SET_OK:
            print(&#34;Raspberry Pi will shutdown in 5 seconds!&#34;)
            os.system(&#34;sleep 5 &amp;&amp; sudo shutdown -h now&#34;)
            return result2

    return Definition.SET_FAILED</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.soft_reboot"><code class="name flex">
<span>def <span class="ident">soft_reboot</span></span>(<span>self, timeout=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for checking any soft reboot request is exist. If any
request exist, raspberry pi reboots by using "sudo reboot" terminal
command in 5 seconds.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for EXIST, "2" for NOT_EXIST</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soft_reboot(self, timeout=RESPONSE_DELAY):
    &#34;&#34;&#34;
    Function for checking any soft reboot request is exist. If any
    request exist, raspberry pi reboots by using &#34;sudo reboot&#34; terminal
    command in 5 seconds.
    
    Parameters
    -----------
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Returns
    ------- 
    result : int
        &#34;1&#34; for EXIST, &#34;2&#34; for NOT_EXIST
    &#34;&#34;&#34;

    command.create_command(command.PROTOCOL_COMMAND_SOFT_REBOOT)
    command.send_command()
    delay_ms(timeout)
    raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)

    result2 = 0
    result = raw[PROTOCOL_HEADER_SIZE]

    if result == Definition.SET_OK:
        command.create_set_command(command.PROTOCOL_COMMAND_SOFT_REBOOT, 1, 1)
        command.send_command()
        delay_ms(timeout)
        raw = command.receive_command(COMMAND_SIZE_FOR_UINT8)
        result2 = raw[PROTOCOL_HEADER_SIZE]

        if result2 == Definition.SET_OK:
            print(&#34;Raspberry Pi will shutdown in 5 seconds!&#34;)
            os.system(&#34;sleep 5 &amp;&amp; sudo reboot&#34;)
            return result2

    return Definition.SET_FAILED</code></pre>
</details>
</dd>
<dt id="power_api.power_api.SixfabPower.update_firmware"><code class="name flex">
<span>def <span class="ident">update_firmware</span></span>(<span>self, firmware_file, update_method=0, timeout=25)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for updating mcu firmware. Do not make any other api call while update call is running.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>firmware_file</code></strong> :&ensp;<code>str</code></dt>
<dd>.bin file path</dd>
<dt><strong><code>update_method</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>"0" for boot_mode_update, "1" for firmware_mode_update (default is 0)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int (optional)</code></dt>
<dd>timeout while receiving the response (default is RESPONSE_DELAY)</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>process</code></strong> :&ensp;<code>int</code></dt>
<dd>Process [%] on every step</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>result : int
"1" for SUCCESS, "2" for FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_firmware(self, firmware_file, update_method=0, timeout=25):
    &#34;&#34;&#34;
    Function for updating mcu firmware. Do not make any other api call while update call is running.
    
    Parameters
    -----------
    firmware_file : str
        .bin file path
    update_method : int (optional)
        &#34;0&#34; for boot_mode_update, &#34;1&#34; for firmware_mode_update (default is 0)
    timeout : int (optional)
        timeout while receiving the response (default is RESPONSE_DELAY)

    Yields
    ------
    process : int
        Process [%] on every step

    Returns
    ------- 
    result : int
        &#34;1&#34; for SUCCESS, &#34;2&#34; for FAIL
    &#34;&#34;&#34;

    packet_id = 0
    requesting_packet_id = 1
    packet_size = 20

    # Calculate packet count
    f = open(firmware_file, &#34;rb&#34;)
    all_data = f.read()
    leap_packet_size = len(all_data) % packet_size
    packet_count = int(len(all_data) / packet_size) + 1
    
    if leap_packet_size == 0:
         packet_count = int(len(all_data) / packet_size)

    f.close()

    # open file
    f = open(firmware_file, &#34;rb&#34;)
    data = bytes()

    # Clear program storage for saving new program data
    result = self.clear_program_storage()
    # print(&#34;Program Storage Clear Result: &#34; + str(result))
    if result != 1:
        return Definition.SET_FAILED

    last_process = 0  # for process bar

    # choose the update_method
    if update_method == 0:
        self.reset_for_boot_update()
        delay_ms(800)

    # If any data exist
    while data or (packet_id == 0):
        if packet_id != requesting_packet_id:
            data = f.read(packet_size)
            packet_id += 1

        # calculate the process
        process = int((packet_id * 100) / packet_count)
        yielded_value = None

        if process != last_process:
            if yielded_value != process:
                yielded_value = process
                yield process

            last_process = process

        # send data to MCU
        if data:
            if packet_id == packet_count:
                command.create_firmware_update_command(
                    packet_count,
                    requesting_packet_id,
                    data,
                    packet_len=leap_packet_size,
                )
                command.send_command()
                delay_ms(timeout)
                raw = command.receive_command(COMMAND_SIZE_FOR_INT16)
            else:
                command.create_firmware_update_command(
                    packet_count, requesting_packet_id, data
                )
                command.send_command()
                delay_ms(timeout)
                raw = command.receive_command(COMMAND_SIZE_FOR_INT16)

            try:
                requesting_packet_id = (raw[5] &lt;&lt; 8) | (raw[6] &amp; 0xFF)
                # print(&#34;Last Packet Read --&gt; &#34; + str(packet_id))
                # print(&#34;Requesting --&gt; &#34; + str(requesting_packet_id))

                # if final packet comes
                if requesting_packet_id == 0xFFFF:
                    print(&#34;Firmware packages are being writen to flash...&#34;)
                    print(&#34;Please wait until the application starts!&#34;)
                    self.reset_mcu()
                    return
            except:
                raise ValueError(&#34;None Object Exception&#34;)

    # if firmware update doesn&#39;t ended succesfully
    raise RuntimeError(&#34;Unidentified Runtime Exception&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="power_api" href="index.html">power_api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="power_api.power_api.debug_print" href="#power_api.power_api.debug_print">debug_print</a></code></li>
<li><code><a title="power_api.power_api.delay_ms" href="#power_api.power_api.delay_ms">delay_ms</a></code></li>
<li><code><a title="power_api.power_api.millis" href="#power_api.power_api.millis">millis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="power_api.power_api.SixfabPower" href="#power_api.power_api.SixfabPower">SixfabPower</a></code></h4>
<ul class="">
<li><code><a title="power_api.power_api.SixfabPower.ask_watchdog_alarm" href="#power_api.power_api.SixfabPower.ask_watchdog_alarm">ask_watchdog_alarm</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.board" href="#power_api.power_api.SixfabPower.board">board</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.clear_program_storage" href="#power_api.power_api.SixfabPower.clear_program_storage">clear_program_storage</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.create_scheduled_event" href="#power_api.power_api.SixfabPower.create_scheduled_event">create_scheduled_event</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.create_scheduled_event_with_event" href="#power_api.power_api.SixfabPower.create_scheduled_event_with_event">create_scheduled_event_with_event</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_battery_current" href="#power_api.power_api.SixfabPower.get_battery_current">get_battery_current</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_battery_design_capacity" href="#power_api.power_api.SixfabPower.get_battery_design_capacity">get_battery_design_capacity</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_battery_health" href="#power_api.power_api.SixfabPower.get_battery_health">get_battery_health</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_battery_level" href="#power_api.power_api.SixfabPower.get_battery_level">get_battery_level</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_battery_max_charge_level" href="#power_api.power_api.SixfabPower.get_battery_max_charge_level">get_battery_max_charge_level</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_battery_power" href="#power_api.power_api.SixfabPower.get_battery_power">get_battery_power</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_battery_temp" href="#power_api.power_api.SixfabPower.get_battery_temp">get_battery_temp</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_battery_voltage" href="#power_api.power_api.SixfabPower.get_battery_voltage">get_battery_voltage</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_button1_status" href="#power_api.power_api.SixfabPower.get_button1_status">get_button1_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_button2_status" href="#power_api.power_api.SixfabPower.get_button2_status">get_button2_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_edm_status" href="#power_api.power_api.SixfabPower.get_edm_status">get_edm_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_fan_automation" href="#power_api.power_api.SixfabPower.get_fan_automation">get_fan_automation</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_fan_health" href="#power_api.power_api.SixfabPower.get_fan_health">get_fan_health</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_fan_mode" href="#power_api.power_api.SixfabPower.get_fan_mode">get_fan_mode</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_fan_speed" href="#power_api.power_api.SixfabPower.get_fan_speed">get_fan_speed</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_firmware_ver" href="#power_api.power_api.SixfabPower.get_firmware_ver">get_firmware_ver</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_input_current" href="#power_api.power_api.SixfabPower.get_input_current">get_input_current</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_input_power" href="#power_api.power_api.SixfabPower.get_input_power">get_input_power</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_input_temp" href="#power_api.power_api.SixfabPower.get_input_temp">get_input_temp</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_input_voltage" href="#power_api.power_api.SixfabPower.get_input_voltage">get_input_voltage</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_lpm_status" href="#power_api.power_api.SixfabPower.get_lpm_status">get_lpm_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_rgb_animation" href="#power_api.power_api.SixfabPower.get_rgb_animation">get_rgb_animation</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_rtc_time" href="#power_api.power_api.SixfabPower.get_rtc_time">get_rtc_time</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_safe_shutdown_battery_level" href="#power_api.power_api.SixfabPower.get_safe_shutdown_battery_level">get_safe_shutdown_battery_level</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_safe_shutdown_status" href="#power_api.power_api.SixfabPower.get_safe_shutdown_status">get_safe_shutdown_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_scheduled_event_ids" href="#power_api.power_api.SixfabPower.get_scheduled_event_ids">get_scheduled_event_ids</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_system_current" href="#power_api.power_api.SixfabPower.get_system_current">get_system_current</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_system_power" href="#power_api.power_api.SixfabPower.get_system_power">get_system_power</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_system_temp" href="#power_api.power_api.SixfabPower.get_system_temp">get_system_temp</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_system_voltage" href="#power_api.power_api.SixfabPower.get_system_voltage">get_system_voltage</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_watchdog_status" href="#power_api.power_api.SixfabPower.get_watchdog_status">get_watchdog_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.get_working_mode" href="#power_api.power_api.SixfabPower.get_working_mode">get_working_mode</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.hard_power_off" href="#power_api.power_api.SixfabPower.hard_power_off">hard_power_off</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.hard_reboot" href="#power_api.power_api.SixfabPower.hard_reboot">hard_reboot</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.remove_all_scheduled_events" href="#power_api.power_api.SixfabPower.remove_all_scheduled_events">remove_all_scheduled_events</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.remove_scheduled_event" href="#power_api.power_api.SixfabPower.remove_scheduled_event">remove_scheduled_event</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.reset_for_boot_update" href="#power_api.power_api.SixfabPower.reset_for_boot_update">reset_for_boot_update</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.reset_mcu" href="#power_api.power_api.SixfabPower.reset_mcu">reset_mcu</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.send_system_temp" href="#power_api.power_api.SixfabPower.send_system_temp">send_system_temp</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_battery_design_capacity" href="#power_api.power_api.SixfabPower.set_battery_design_capacity">set_battery_design_capacity</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_battery_max_charge_level" href="#power_api.power_api.SixfabPower.set_battery_max_charge_level">set_battery_max_charge_level</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_edm_status" href="#power_api.power_api.SixfabPower.set_edm_status">set_edm_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_fan_automation" href="#power_api.power_api.SixfabPower.set_fan_automation">set_fan_automation</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_fan_mode" href="#power_api.power_api.SixfabPower.set_fan_mode">set_fan_mode</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_lpm_status" href="#power_api.power_api.SixfabPower.set_lpm_status">set_lpm_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_rgb_animation" href="#power_api.power_api.SixfabPower.set_rgb_animation">set_rgb_animation</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_rtc_time" href="#power_api.power_api.SixfabPower.set_rtc_time">set_rtc_time</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_safe_shutdown_battery_level" href="#power_api.power_api.SixfabPower.set_safe_shutdown_battery_level">set_safe_shutdown_battery_level</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_safe_shutdown_status" href="#power_api.power_api.SixfabPower.set_safe_shutdown_status">set_safe_shutdown_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.set_watchdog_status" href="#power_api.power_api.SixfabPower.set_watchdog_status">set_watchdog_status</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.soft_power_off" href="#power_api.power_api.SixfabPower.soft_power_off">soft_power_off</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.soft_reboot" href="#power_api.power_api.SixfabPower.soft_reboot">soft_reboot</a></code></li>
<li><code><a title="power_api.power_api.SixfabPower.update_firmware" href="#power_api.power_api.SixfabPower.update_firmware">update_firmware</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>